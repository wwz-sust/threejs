<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script type="importmap">
    {
        "imports": {
            "three": "../js/three.module.min.js",
            "controls": "../jsm/controls/OrbitControls.js"
        }
    }
    </script>
<script type="module">
    import * as THREE from "three";
    // 初始化Three.js场景
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 创建圆形路径
    // var radius = 5;
    // var segments = 64;
    // var circleGeometry = new THREE.CircleGeometry(radius, segments);
    // var circleMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    // var circle = new THREE.LineLoop(circleGeometry, circleMaterial);
    // scene.add(circle);


    // 创建圆形几何体
    var radius = 5; // 圆的半径
    var segments = 64; // 圆的线段数
    var positions = [];

    for (var i = 0; i <= segments; i++) {
        var angle = (i / segments) * Math.PI * 2;
        positions.push(radius * Math.cos(angle), radius * Math.sin(angle), 0);
    }

    var circleGeometry = new THREE.BufferGeometry();
    circleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

    var circleMaterial = new THREE.LineBasicMaterial({ color: 0xffffff }); // 线的材质
    var circle = new THREE.LineLoop(circleGeometry, circleMaterial); // 创建线
    scene.add(circle);
    

    // 动画循环
    function animate() {
        requestAnimationFrame(animate);

        // 更新球体位置
        angle += 0.01; // 每帧增加的角度
        x = radius * Math.cos(angle);
        y = radius * Math.sin(angle);
        sphere.position.set(x, y, 0);

        // 使球体朝向路径的切线方向（可选）
        // var tangent = new THREE.Vector3().subVectors(circle.geometry.vertices[(segments / 4) % segments], circle.geometry.vertices[(segments / 4 - 1) % segments]).normalize();
        // sphere.lookAt(tangent);

        renderer.render(scene, camera);
    }

    // 调整摄像机位置
    camera.position.z = 10;
    renderer.render(scene, camera);

    // animate();

</script>

</html>